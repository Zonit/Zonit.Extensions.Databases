using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Zonit.Extensions.Databases.SourceGenerators;

/// <summary>
/// Source generator that creates AOT-compatible extension type resolver.
/// Automatically discovers extensions by finding classes implementing IDatabaseExtension&lt;T&gt;.
/// No attributes required.
/// </summary>
[Generator]
public class ExtensionResolverGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes implementing IDatabaseExtension<T>
        var extensionDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateExtension(s),
                transform: static (ctx, _) => GetExtensionFromInterface(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndExtensions = context.CompilationProvider
            .Combine(extensionDeclarations.Collect());

        // Generate the source
        context.RegisterSourceOutput(compilationAndExtensions,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateExtension(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.BaseList is not null &&
               classDecl.BaseList.Types.Any(t => t.ToString().Contains("IDatabaseExtension"));
    }

    private static ExtensionInfo? GetExtensionFromInterface(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        if (symbol is null)
            return null;

        // Find IDatabaseExtension<T> interface
        var extensionInterface = symbol.AllInterfaces.FirstOrDefault(i =>
            i.IsGenericType &&
            i.Name == "IDatabaseExtension" &&
            i.TypeArguments.Length == 1);

        if (extensionInterface is null)
            return null;

        var entityType = extensionInterface.TypeArguments.FirstOrDefault();
        if (entityType is null)
            return null;

        return new ExtensionInfo
        {
            ClassName = symbol.Name,
            FullClassName = symbol.ToDisplayString(),
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            EntityTypeName = entityType.ToDisplayString()
        };
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ExtensionInfo?> extensions,
        SourceProductionContext context)
    {
        var allExtensions = extensions
            .Where(e => e is not null)
            .Cast<ExtensionInfo>()
            .GroupBy(e => e.FullClassName)
            .Select(g => g.First())
            .ToList();

        if (allExtensions.Count == 0)
            return;

        var source = GenerateExtensionResolver(allExtensions);
        context.AddSource("ExtensionTypeResolver.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateExtensionResolver(List<ExtensionInfo> extensions)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using Zonit.Extensions.Databases;");
        sb.AppendLine();

        // Add usings for extension namespaces
        var namespaces = extensions.Select(e => e.Namespace).Distinct().OrderBy(n => n);
        foreach (var ns in namespaces)
        {
            if (!string.IsNullOrEmpty(ns) && ns != "Zonit.Extensions.Databases")
                sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace Zonit.Extensions.Databases.Accessors;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// AOT-safe registry mapping entity types to their extension service types.");
        sb.AppendLine("/// Auto-generated partial class implementation.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static partial class ExtensionTypeResolver");
        sb.AppendLine("{");

        // Static mapping: EntityType -> ExtensionType
        sb.AppendLine("    private static readonly FrozenDictionary<Type, Type> _entityToExtensionMap = new Dictionary<Type, Type>");
        sb.AppendLine("    {");
        foreach (var ext in extensions)
        {
            sb.AppendLine($"        [typeof({ext.EntityTypeName})] = typeof({ext.FullClassName}),");
        }
        sb.AppendLine("    }.ToFrozenDictionary();");
        sb.AppendLine();

        // Static mapping: ExtensionType -> EntityType
        sb.AppendLine("    private static readonly FrozenDictionary<Type, Type> _extensionToEntityMap = new Dictionary<Type, Type>");
        sb.AppendLine("    {");
        foreach (var ext in extensions)
        {
            sb.AppendLine($"        [typeof({ext.FullClassName})] = typeof({ext.EntityTypeName}),");
        }
        sb.AppendLine("    }.ToFrozenDictionary();");
        sb.AppendLine();

        // Implement partial methods
        sb.AppendLine("    static partial void GetGeneratedExtensionTypeCore(Type entityType, ref Type? result)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_entityToExtensionMap.TryGetValue(entityType, out var extType))");
        sb.AppendLine("            result = extType;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    static partial void GetGeneratedEntityTypeCore(Type extensionType, ref Type? result)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_extensionToEntityMap.TryGetValue(extensionType, out var entityType))");
        sb.AppendLine("            result = entityType;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    static partial void HandlesEntityGeneratedCore(IDatabaseExtension extension, Type entityType, ref bool result)");
        sb.AppendLine("    {");
        sb.AppendLine("        var extType = extension.GetType();");
        sb.AppendLine("        result = _extensionToEntityMap.TryGetValue(extType, out var handled) && handled == entityType;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    static partial void FindExtensionGeneratedCore(IEnumerable<IDatabaseExtension> extensions, Type entityType, ref IDatabaseExtension? result)");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var ext in extensions)");
        sb.AppendLine("        {");
        sb.AppendLine("            var extType = ext.GetType();");
        sb.AppendLine("            if (_extensionToEntityMap.TryGetValue(extType, out var handled) && handled == entityType)");
        sb.AppendLine("            {");
        sb.AppendLine("                result = ext;");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }
}

internal class ExtensionInfo
{
    public string ClassName { get; set; } = "";
    public string FullClassName { get; set; } = "";
    public string Namespace { get; set; } = "";
    public string EntityTypeName { get; set; } = "";
}
