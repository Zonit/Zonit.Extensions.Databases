using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace Zonit.Extensions.Databases.SourceGenerators;

/// <summary>
/// Source generator that creates AOT-compatible repository implementations.
/// Generates constructors and context properties for classes marked with [Repository] attribute.
/// </summary>
[Generator]
public class RepositoryGenerator : IIncrementalGenerator
{
    private const string RepositoryAttributeName = "Zonit.Extensions.Databases.RepositoryAttribute";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [Repository<TEntity, TContext>] attribute
        var attributedClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsRepositoryAttributeCandidate(s),
                transform: static (ctx, _) => GetAttributedRepositoryInfo(ctx))
            .Where(static m => m is not null);

        // Generate partial class implementations
        context.RegisterSourceOutput(attributedClasses,
            static (spc, info) => GenerateRepositoryImplementation(spc, info!));

        // Find all classes that inherit from SqlServerRepository (for DI registration)
        var repositoryDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateRepository(s),
                transform: static (ctx, _) => GetRepositoryInfo(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndRepositories = context.CompilationProvider
            .Combine(repositoryDeclarations.Collect());

        // Generate the source
        context.RegisterSourceOutput(compilationAndRepositories,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsRepositoryAttributeCandidate(SyntaxNode node)
    {
        // Look for partial class declarations with attributes
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.Modifiers.Any(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword) &&
               classDecl.AttributeLists.Count > 0;
    }

    private static AttributedRepositoryInfo? GetAttributedRepositoryInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol)
            return null;

        // Find [Repository<TEntity, TContext>] attribute
        foreach (var attr in symbol.GetAttributes())
        {
            var attrClass = attr.AttributeClass;
            if (attrClass is null)
                continue;

            var fullName = attrClass.OriginalDefinition.ToDisplayString();
            if (fullName.StartsWith(RepositoryAttributeName))
            {
                // Get generic type arguments from attribute
                if (attrClass.TypeArguments.Length != 2)
                    continue;

                var entityType = attrClass.TypeArguments[0];
                var contextType = attrClass.TypeArguments[1];

                // Find implemented interfaces (e.g., IBlogRepository)
                var interfaces = symbol.Interfaces;

                return new AttributedRepositoryInfo
                {
                    ClassName = symbol.Name,
                    Namespace = symbol.ContainingNamespace.ToDisplayString(),
                    EntityTypeName = entityType.Name,
                    EntityTypeFullName = entityType.ToDisplayString(),
                    ContextTypeName = contextType.Name,
                    ContextTypeFullName = contextType.ToDisplayString(),
                    IsInternal = symbol.DeclaredAccessibility == Accessibility.Internal,
                    Interfaces = interfaces.Select(i => i.ToDisplayString()).ToArray()
                };
            }
        }

        return null;
    }

    private static void GenerateRepositoryImplementation(SourceProductionContext context, AttributedRepositoryInfo info)
    {
        var accessibility = info.IsInternal ? "internal" : "public";
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Zonit.Extensions.Databases.SqlServer;");
        sb.AppendLine();
        sb.AppendLine($"namespace {info.Namespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Auto-generated partial implementation for {info.ClassName}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para><b>Available properties:</b></para>");
        sb.AppendLine("/// <list type=\"bullet\">");
        sb.AppendLine($"///     <item><c>DbContext</c> - Scoped {info.ContextTypeName} for simple CRUD operations</item>");
        sb.AppendLine("///     <item><c>ContextFactory</c> - Factory for parallel queries (pagination, bulk)</item>");
        sb.AppendLine("///     <item><c>ServiceProvider</c> - For resolving additional dependencies</item>");
        sb.AppendLine("/// </list>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine($"{accessibility} partial class {info.ClassName} : SqlServerRepository<{info.EntityTypeFullName}, {info.ContextTypeFullName}>");
        sb.AppendLine("{");

        // Constructor
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of {info.ClassName}.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public {info.ClassName}(");
        sb.AppendLine($"        IDbContextFactory<{info.ContextTypeFullName}> contextFactory,");
        sb.AppendLine("        IServiceProvider serviceProvider)");
        sb.AppendLine("        : base(contextFactory, serviceProvider)");
        sb.AppendLine("    {");
        sb.AppendLine("        ContextFactory = contextFactory;");
        sb.AppendLine("        ServiceProvider = serviceProvider;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ContextFactory property
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the database context factory for creating new contexts.");
        sb.AppendLine("    /// Use this for parallel operations like pagination (items + count) or bulk operations.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <example>");
        sb.AppendLine("    /// <code>");
        sb.AppendLine("    /// await using var ctx1 = await ContextFactory.CreateDbContextAsync();");
        sb.AppendLine("    /// var items = await ctx1.Blogs.Take(10).ToListAsync();");
        sb.AppendLine("    /// ");
        sb.AppendLine("    /// await using var ctx2 = await ContextFactory.CreateDbContextAsync();");
        sb.AppendLine("    /// var count = await ctx2.Blogs.CountAsync();");
        sb.AppendLine("    /// </code>");
        sb.AppendLine("    /// </example>");
        sb.AppendLine($"    protected IDbContextFactory<{info.ContextTypeFullName}> ContextFactory {{ get; }}");
        sb.AppendLine();

        // DbContext property (lazy, scoped)
        sb.AppendLine("    private " + info.ContextTypeFullName + "? _dbContext;");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets a scoped database context for simple CRUD operations.");
        sb.AppendLine("    /// This context is created lazily and shared within the repository scope.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// <b>Warning:</b> Do not dispose this context manually.");
        sb.AppendLine("    /// For parallel operations or long-running tasks, use <see cref=\"ContextFactory\"/> instead.");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine("    /// <example>");
        sb.AppendLine("    /// <code>");
        sb.AppendLine("    /// var blog = await DbContext.Blogs.FindAsync(id);");
        sb.AppendLine("    /// DbContext.Blogs.Add(newBlog);");
        sb.AppendLine("    /// await DbContext.SaveChangesAsync();");
        sb.AppendLine("    /// </code>");
        sb.AppendLine("    /// </example>");
        sb.AppendLine($"    protected {info.ContextTypeFullName} DbContext");
        sb.AppendLine("    {");
        sb.AppendLine("        get");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_dbContext is null)");
        sb.AppendLine("            {");
        sb.AppendLine("                _dbContext = ContextFactory.CreateDbContext();");
        sb.AppendLine("            }");
        sb.AppendLine("            return _dbContext;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // ServiceProvider property
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the service provider for resolving additional dependencies.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    protected IServiceProvider ServiceProvider { get; }");

        sb.AppendLine("}");

        context.AddSource($"{info.ClassName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static bool IsCandidateRepository(SyntaxNode node)
    {
        // Look for class declarations with base class
        return node is ClassDeclarationSyntax classDecl &&
               classDecl.BaseList is not null &&
               classDecl.BaseList.Types.Count > 0;
    }

    private static RepositoryInfo? GetRepositoryInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        // Get semantic model
        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol)
            return null;

        // Check if it inherits from SqlServerRepository
        var baseType = symbol.BaseType;
        while (baseType is not null)
        {
            var baseTypeName = baseType.OriginalDefinition.ToDisplayString();
            if (baseTypeName.StartsWith("Zonit.Extensions.Databases.SqlServer.SqlServerRepository<"))
            {
                // Found a repository
                var interfaces = symbol.Interfaces;
                var repositoryInterface = interfaces.FirstOrDefault(i =>
                    i.Name.EndsWith("Repository") && i.Name.StartsWith("I"));

                return new RepositoryInfo
                {
                    ClassName = symbol.Name,
                    FullClassName = symbol.ToDisplayString(),
                    Namespace = symbol.ContainingNamespace.ToDisplayString(),
                    InterfaceName = repositoryInterface?.ToDisplayString(),
                    EntityType = baseType.TypeArguments.Length > 0
                        ? baseType.TypeArguments[0].ToDisplayString()
                        : null,
                    ContextType = baseType.TypeArguments.Length > 1
                        ? baseType.TypeArguments[1].ToDisplayString()
                        : null,
                    IsInternal = symbol.DeclaredAccessibility == Accessibility.Internal
                };
            }
            baseType = baseType.BaseType;
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<RepositoryInfo?> repositories,
        SourceProductionContext context)
    {
        if (repositories.IsDefaultOrEmpty)
            return;

        var validRepositories = repositories
            .Where(r => r is not null)
            .Cast<RepositoryInfo>()
            .ToList();

        if (validRepositories.Count == 0)
            return;

        // Group by namespace
        var byNamespace = validRepositories
            .GroupBy(r => GetRootNamespace(r.Namespace ?? ""))
            .ToList();

        foreach (var group in byNamespace)
        {
            var source = GenerateRegistrationExtensions(group.Key, group.ToList());
            context.AddSource($"{group.Key}.RepositoryRegistration.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GetRootNamespace(string ns)
    {
        var parts = ns.Split('.');
        return parts.Length >= 2 ? $"{parts[0]}.{parts[1]}" : ns;
    }

    private static string GenerateRegistrationExtensions(string rootNamespace, List<RepositoryInfo> repositories)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine();

        // Add using statements for all unique namespaces
        var namespaces = repositories
            .Select(r => r.Namespace)
            .Where(n => !string.IsNullOrEmpty(n))
            .Distinct()
            .OrderBy(n => n);

        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {rootNamespace}.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated repository registration extensions.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class RepositoryRegistrationExtensions");
        sb.AppendLine("{");

        // Generate AddRepositories method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Registers all discovered repositories in the DI container.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IServiceCollection AddRepositories(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var repo in repositories)
        {
            if (!string.IsNullOrEmpty(repo.InterfaceName))
            {
                var lifetime = "Transient"; // Could be configurable
                sb.AppendLine($"        services.Add{lifetime}<{repo.InterfaceName}, {repo.FullClassName}>();");
            }
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");

        // Generate individual Add methods
        foreach (var repo in repositories)
        {
            if (!string.IsNullOrEmpty(repo.InterfaceName))
            {
                sb.AppendLine();
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Registers {repo.ClassName} repository.");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    public static IServiceCollection Add{repo.ClassName}(this IServiceCollection services)");
                sb.AppendLine("    {");
                sb.AppendLine($"        services.AddTransient<{repo.InterfaceName}, {repo.FullClassName}>();");
                sb.AppendLine("        return services;");
                sb.AppendLine("    }");
            }
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
}

internal class RepositoryInfo
{
    public string? ClassName { get; set; }
    public string? FullClassName { get; set; }
    public string? Namespace { get; set; }
    public string? InterfaceName { get; set; }
    public string? EntityType { get; set; }
    public string? ContextType { get; set; }
    public bool IsInternal { get; set; }
}

internal class AttributedRepositoryInfo
{
    public string? ClassName { get; set; }
    public string? Namespace { get; set; }
    public string? EntityTypeName { get; set; }
    public string? EntityTypeFullName { get; set; }
    public string? ContextTypeName { get; set; }
    public string? ContextTypeFullName { get; set; }
    public bool IsInternal { get; set; }
    public string[]? Interfaces { get; set; }
}
